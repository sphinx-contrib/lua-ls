Generating documentation for objects
====================================

You can automatically generate object descriptions based on Lua source code.

Depending on which language analyzer you use, documentation comments
can be slightly different:

.. tab-set::
   :sync-group: backend

   .. tab-item:: EmmyLua
      :sync: emmylua

      EmmyLua doesn't need any specific annotations beyond the standard documentation
      comments.

      When generating documentation for a module, Sphinx-LuaLs will include
      all module's objects returned by `require`, as well as all types located
      in the same namespace.

      That is, for module `meow`, it will list everything in the ``require("meow")``,
      as well as all classes, aliases, and enums that have prefix ``meow.*``.

      Thus, a typical Lua module will look like this:

      .. code-block:: lua

         --- A module for meowing and purring.
         local meow = {}

         --- A function exported from a module.
         function meow.meow() end

         --- Another function exported from a module.
         function meow.purr() end

         --- This class will be included in the documentation
         --- for module `meow` because it's located in the namespace `meow`.
         ---
         --- @class meow.MeowingBackend

         return meow

      .. tip::

         You don't have to manually prefix names of all types.
         Use ``@namespace`` to indicate that all types in a module
         belong to a certain namespace:

         .. code-block:: lua
            :emphasize-lines: 1,8-11

            --- @namespace meow

            --- A module for meowing and purring.
            local meow = {}

            ...

            --- This class will appear in namespace `meow` even though
            --- we didn't write its full path.
            ---
            --- @class MeowingBackend

            return meow

      .. note::

         By default, Sphinx-LuaLs will parse object comments as ReStructured Text,
         not as MarkDown. If you plan to use Markdown in code comments,
         install the `MySt`_ plugin for Sphinx and invoke
         :rst:dir:`lua:autoobject` from a markdown file.

   .. tab-item:: LuaLs
      :sync: luals

      Tables are exported as ``data`` by default,
      meaning that their contents are not documented.

      To enable documentation within a table, annotate is as a class.
      You can change how Sphinx-LuaLs infers its type by adding a ``!doctype`` comment.

      Thus, a typical Lua module will look like this:

      .. code-block:: lua

         --- This is a module. Notice that we've declared it as a class
         --- and added a `doctype`.
         ---
         --- !doctype module
         --- @class meow
         local meow = {}

         --- Nested namespaces should also be declared as classes.
         ---
         --- !doctype table
         --- @class meow.utils
         meow.utils = {}

         --- Other objects are documented as usual.
         function meow.purr() end

         --- This class will be included in the documentation
         --- for module `meow` because it's located in the namespace `meow`.
         ---
         --- @class meow.MeowingBackend

         return meow

      .. note::

         By default, Sphinx-LuaLs will parse object comments as ReStructured Text,
         not as MarkDown. If you plan to use Markdown in code comments,
         install the `MySt`_ plugin for Sphinx and invoke include
         :rst:dir:`lua:autoobject` from a markdown file.

         Make sure to separate comment markers from documentation with a space.
         Otherwise, Sphinx-LuaLs will not be able to tell your comments apart
         from content automatically generated by Lua Language Server:

         .. code-block:: lua

            --- This is OK: separated by a space.
            local x = 0;

            ---This is NOT OK: no separation.
            local x = 0;

      .. warning::

         Currently, Lua Language Server does not export all available information.

         1. ``@see`` markers can sometimes be broken. We recommend using
            the :rst:dir:`seealso` directive instead.

         2. ``@deprecated`` markers do not add any note to the documentation.
            We recommend providing an explicit message
            with the ``deprecated`` directive.

         3. ``@nodiscard`` and ``@operator`` markers are not exported.

         4. Export of aliases (``@alias``) is somewhat broken. Documentation
            for an alias is appended to every object that mentions it.
            While Sphinx-LuaLs tries its best to remove it, there's no way
            to completely remedy this issue.

         5. Export of enums (``@enum``) is completely broken.
            We recommend using ``@alias`` instead:

            .. code-block:: lua

               --- Instead of enums, we use aliases.
               ---
               --- .. lua:data:: Debug
               ---
               ---    Document alias members in its body.
               ---
               --- And so on...
               ---
               --- @alias logging.LogLevel integer
               LogLevel = {
                  Debug = 1,
                  -- ...
               }


Autodoc directive
-----------------

.. rst:directive:: .. lua:autoobject:: name

   Automatically generates documentation for the given object.

   :rst:dir:`lua:autoobject` supports same settings as other lua directives,
   as well as some additional ones:

   .. rst:directive:option:: members

      If enabled, autodoc will also document object's members. You can pass a list
      of comma-separated names to specify which members should be documented.
      Otherwise, this option will document all public non-special members
      which have a description.

   .. rst:directive:option:: undoc-members

      Include undocumented members to the object's description. By default,
      they are skipped even if :rst:dir:`members` is passed.

      Accepts a comma-separated list of names; if list is empty,
      adds all undoc members.

   .. rst:directive:option:: private-members
                             protected-members
                             package-members

      Include non-public members to the object's description.

      Accepts a comma-separated list of names; if list is empty,
      adds all non-public members.

   .. rst:directive:option:: special-members

      Include members whose names start with double underscore
      to the object's description.

      Accepts a comma-separated list of names; if list is empty,
      adds all special members.

   .. rst:directive:option:: inherited-members

      For classes, include members inherited from base classes.

      Accepts a comma-separated list of names; if list is empty,
      adds all inherited members.

   .. rst:directive:option:: exclude-members

      A comma-separated list of members that should not be documented.

   .. rst:directive:option:: globals

      Will include global variables declared in the corresponding module.

      Accepts a comma-separated list of names; if list is empty,
      adds all global variables.

   .. rst:directive:option:: class-doc-from

      Specifies how to generate documentation for classes
      if :py:data:`class_default_function_name` is configured.

      Options are:

      - ``class``: only use documentation from ``@class`` annotation,

      - ``ctor``: only use documentation from class constructor,

      - ``both``: use documentation from ``@class`` annotation and constructor,
        place them one next to another.

      - ``separate``: only use documentation from ``@class`` annotation,
        document class constructor as a separate method.

   .. rst:directive:option:: class-signature

      Specifies how to generate signatures for classes
      if :py:data:`class_default_function_name` is configured.

      Options are:

      - ``bases``: only show base classes,

      - ``ctor``: only show constructor arguments,

      - ``both``: show base classes and constructor arguments,

      - ``minimal``: show bases and/or constructor arguments if either is present.

      .. dropdown:: Example

         **Bases:**

         .. lua:autoobject:: logging.Logger
            :no-index:
            :class-doc-from: class
            :class-signature: bases

         **Ctor:**

         .. lua:autoobject:: logging.Logger
            :no-index:
            :class-doc-from: class
            :class-signature: ctor

         **Both:**

         .. lua:autoobject:: logging.Logger
            :no-index:
            :class-doc-from: class
            :class-signature: both

         **Minimal:**

         .. lua:autoobject:: logging.Logger
            :no-index:
            :class-doc-from: class
            :class-signature: minimal

   .. rst:directive:option:: recursive

      If enabled, autodoc will recursively generate documentation
      for all objects nested within the root. That is, object's members,
      their members, and so on.

      If
      :rst:dir:`lua:autoobject:members`,
      :rst:dir:`lua:autoobject:globals`,
      :rst:dir:`lua:autoobject:undoc-members`,
      :rst:dir:`lua:autoobject:private-members`,
      :rst:dir:`lua:autoobject:special-members`,
      or :rst:dir:`lua:autoobject:inherited-members`
      are given as flags, they are propagated to all documented objects.

      If they're given as list, they are not propagated.

      Options from :py:data:`lua_ls_default_options` are applied to all recursively
      documented objects.

   .. rst:directive:option:: member-order

      Controls how members are sorted. There are three options available:

      - ``alphabetical``: members are sorted in lexicographical order of their names;

      - ``groupwise``: members are grouped by their type. Within each group, they are
        ordered by name;

      - ``bysource``: members are sorted in the same order as they appear in code.
        This is the default option.

   .. rst:directive:option:: module-member-order

      Overrides :rst:dir:`lua:autoobject:member-order` for modules.

   .. rst:directive:option:: title

      For modules, controls whether a title is inserted between module description
      and documentation of its members.

   .. rst:directive:option:: index-table

      Adds :rst:dir:`lua:autoindex` to the toplevel module.

   .. rst:directive:option:: index-title

      Allows overriding title of the :rst:dir:`lua:autoindex` section.

   .. rst:directive:option:: inherited-members-table

      Adds :rst:dir:`lua:other-inherited-members` to all classes.

   .. rst:directive:option:: annotate-require

      Adds information about how to require a module.

      Options are:

      - ``always``: always show how to require a module;

      - ``never``: never show how to require a module;

      - ``auto``: only show how to require a module if the module's exported type
        is not a table;

      - ``force``: always show how to require a module,
        even if lua analyzer didn't export this information.

      .. warning::

         LuaLs only supports ``never`` and ``force``.

   .. rst:directive:option:: require-function-name

      Allows overriding name of the `require` function
      for :rst:dir:`lua:autoobject:annotate-require`.

   .. rst:directive:option:: require-separator

      Allows overriding separator
      for :rst:dir:`lua:autoobject:annotate-require`.

.. rst:directive:: .. lua:autoindex:: module-name

   Creates a table that references all documented objects in the module ``module-name``.
   This is useful for creating module's table of contents.

   If ``module-name`` is not given, :rst:dir:`lua:autoindex` will use current module.

   If given, module name must be absolute, even if this directive appears after
   :rst:dir:`lua:module`.

.. rst:directive:: .. lua:other-inherited-members:: class-name

   Creates a list of all members that class ``class-name``
   inherited from its bases but didn't document
   with :rst:dir:`lua:autoobject:inherited-members`.

   If ``class-name`` is not given, :rst:dir:`lua:other-inherited-members`
   will use current class.

   If given, class name must be absolute, even if this directive appears after
   :rst:dir:`lua:module`.


Controlling generation from code comments
-----------------------------------------

When using :rst:dir:`lua:autoobject` in recursive mode, it is sometimes necessary
to override its options for some objects. To do this, you can include specially
formatted comments to your documentation.

.. tab-set::
   :sync-group: backend

   .. tab-item:: EmmyLua
      :sync: emmylua

      To override any :rst:dir:`lua:autoobject` setting for a particular object,
      use ``@doc`` comments. For example, here we enable :rst:dir:`lua:autoobject:special-members`
      and exclude ``__tostring`` for class ``Foo``:

      .. code-block:: lua

         --- Some class documentation...
         ---
         --- @doc special-members
         --- @doc exclude-members __tostring
         --- @class Foo

      You can also specify which type of object is being documented by using
      a ``@doctype`` comment. For example, here we use ``@doctype const`` to indicate
      that a certain variable should be documented as :rst:dir:`lua:const`:

      .. code-block:: lua

         --- Some const documentation...
         ---
         --- @doctype const
         --- @type string
         foo = "bar!"

      .. note::

         LuaLs-style ``!doc`` and ``!doctype`` comments are also supported.
         However, we recommend switching to ``@doc`` and ``@doctype``
         because EmmyLua provides a proper syntax highlighting for them.

   .. tab-item:: LuaLs
      :sync: luals

      To override any :rst:dir:`lua:autoobject` setting for a particular object,
      use ``!doc`` comments. For example, here we enable :rst:dir:`lua:autoobject:special-members`
      and exclude ``__tostring`` for class ``Foo``:

      .. code-block:: lua

         --- Some class documentation...
         ---
         --- !doc special-members
         --- !doc exclude-members: __tostring
         --- @class Foo

      You can also specify which type of object is being documented by using
      a ``!doctype`` comment. For example, here we use ``!doctype const`` to indicate
      that a certain variable should be documented as :rst:dir:`lua:const`:

      .. code-block:: lua

         --- Some const documentation...
         ---
         --- !doctype const
         --- @type string
         foo = "bar!"

.. _MySt: https://myst-parser.readthedocs.io/en/latest/index.html
